---
title: "Spatial analysis"
author: "Juliano Palacios-Abrantes"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}

library(MyFunctions)

my_lib(
  c(
    "readxl",
    "tidyverse",
    "sf",
    "st",
    "janitor",
    # For grid estimation 
    "spatialEco", "geosphere","raster","units","matrixStats","rmapshaper", "igraph"
  )
)

# Fix new updates of sf package
sf::sf_use_s2(use_s2 = FALSE)

select <- dplyr::select

knitr::opts_chunk$set(echo = TRUE)


# Change paths to your computer

data_path <- "~/Library/CloudStorage/GoogleDrive-jepa88@gmail.com/My Drive/lenfest_mpa_project/data/"

```

# Load in grid data

```{r grid, eval = T, echo = F}

# World grid
grid <- read_sf(paste0(data_path,"spatial/worldsq_ea/", name ="worldsq_EA.shp"))

# cut the ETP region
grid <- grid %>% filter(Lat > -4 & Lat < 9 & Lon > -95 & Lon < -77)

ggplot(grid) +
  geom_sf()
```

# Shapefile Data

```{r mpa_shape, eval = T, echo = F, message = F,warning = FALSE, cache = FALSE}


mpa_name <- 
  # "Galapagos_Ecuador"
  # "Hermandad_Ecuador"
  # "Yurupari _Malpelo_Colombia"
  # "PN_IslaCoco_CostaRica"
  "Malpelo_Colombia"
  # "CoibaCoord_Panama"
  # "Coiba_Panama"
  # "PN_IslaCoco_CostaRica"
  # "AMM_Bicentenario_CostaRica"
  # "CLomas Sub  Cuenca PacNor"
  # "Gorgona"

path_mpa <- paste0(data_path,"spatial/cmar_capas/",mpa_name,".shp")


suppressMessages(
  mpa_sf <- st_read(path_mpa) %>% 
    # Remove the Z component for ease computation
    st_zm(drop = TRUE)
)
#get out coordinate reference system information 
# st_crs(mpa_sf)
st_crs(mpa_sf)$epsg
crs <- st_crs(mpa_sf)


ggplot(mpa_sf) +
  geom_sf(aes(), fill = "salmon")

ggsave(
  paste0(data_path,"spatial/gridded/",mpa_name,".png"),
  plot = last_plot()
)


```


## Identify grids that are MPAs, surrounding an MPA and no-protected

### 1.1 Identify grids that are MPAs

In this step we identify which grid cells have an MPA completely or partially covering it. 

```{r mpa_overla, eval=T, echo=F, message=FALSE}

# transform grid to shapefile crs
grid <- st_transform(grid, crs = st_crs(crs)) %>% 
  filter(PWater > 0)

# Intersect the grid and the MPA shapefile
grid_intersection <- st_intersection(grid, mpa_sf) %>%
  group_by(Seq) %>%
  summarise(geom = st_union(geometry)) %>%
  mutate(geom = st_sfc(geom),
         area = st_area(geom)) %>% 
  mutate(status = "protected") %>% 
  as.data.frame()

# Identify grid cells that have some level of MPA within them 
grid2 <- as.data.frame(grid) %>% 
  left_join(grid_intersection, by = "Seq") %>% 
  mutate(protected_area_m2 = as.numeric(area)) %>% 
  select(-geom) %>% 
  st_as_sf()

# Plot it
ggplot() + 
  geom_sf(data = grid2, 
          aes(fill = protected_area_m2)) +
  geom_sf(data = mpa_sf, 
          aes(), fill = NA, color = "white") +
  scale_fill_viridis_b()


```

### 1.2 Estimate area

Here we estimate the proportion of the grid cell that is protected using the area protected ($area_p$) relative to the area of the grid cell ($area_g$) in order to reduce fishing effort in grid celss that contain an MPA ($FE_{mpa}$):

$FE_{mpa} = \frac{area_p}{area_g}$

```{r area_est, eval = T, echo = F}

grid2 <- grid2 %>% 
  mutate(grid_area = st_area(.)) %>%
  drop_units() %>% 
  mutate(
    prop = ifelse(status == "protected", (protected_area_m2/grid_area), 1)
  ) 


ggplot() +
  geom_sf(data = grid2, aes(fill = prop)) +
  scale_fill_viridis_b("Proportion of grid\nprotected")
```

### 1.3 Find surrounding grid cells 

Surrounding grid cells are limited to the grid cells immediately adjacent to a grid cell that is cover (complete or partially) by an MPA. The identification of surrounding grid cells is necessary to further re-allocate fishing effort to these cells as they benefit from the biomass spillover.


```{r surroundig, eval = T, echo = F, message = F}

grid_mpa <- grid2 %>% 
  select(OBJECTID, Seq, Lat, Lon, geometry, status, protected_area_m2, grid_area)

# Identify non-protected
grid_mpa_no <- grid_mpa %>% filter(is.na(status))

#create buffer
buffer <- st_buffer(grid_mpa %>% filter(status == "protected"),0.1)

intr <- st_intersection(grid_mpa_no, buffer)
intr_seqs <- c(intr$Seq)

grid_surround <- grid_mpa_no %>% 
  filter(Seq %in% intr_seqs) %>% 
  mutate(surrounding ="surrounding") %>% 
  select(Seq, surrounding)


ggplot() +
  geom_sf(data = grid_surround , aes(), fill = "darkblue") +
  geom_sf(data = grid_mpa %>% filter(status == "protected"), aes(), fill = "pink") +
  geom_sf(data = mpa_sf, aes(), fill = NA, color = "black") +
  ggtitle("Showing protected grid cells in pink and surrounding in blue")


ggsave(
  paste0(data_path,"spatial/gridded/",mpa_name,"_protected.png"),
  plot = last_plot()
)

rm(buffer)

```


## Reallocate fishing effort

Here we re-allocate fishing effort from the protected grid cells to those surrounding. We do this proportionally to the protected area and the number of surrounding grid cells. Right now, the proportion is accounted from all MPAs and re-distributed to all grid cells, but this can change. For this we first estimate the proportion to be allocated (*PropAllocate*):


$$PropAllocate = \frac{tot_{mpa}}{tot_{area}}$$

where $tot_{mpa}$ is the sum of the protected area ($m^2$) of all protected grid cells and $tot_{area}$ is the sum of the whole grided area (protected and surrounding). Then, we estimate the allocation of effort by first counting the number of surrounding grid cells and then allocating the proportion to the fishing effort of surrounding cells ($FE_{sur}$):

$$FE_{sur} = 1+\frac{PropAllocate}{n_{surround}}$$
This way, fishing effort in an MPA grid will be reduced by the proportion of the MPA in the grid ($FE_{mpa}$), in surroundings cells will be increased with the proportion allocated ($FE_{sur}$) while all other grid cells (no-protected) will have an DF at MSY.

```{r fiseffort, eval = T, echo = F}

#total proportion 
#this will help allocate fishing effort to the surrounding areas. 
tot_area = sum(grid_mpa$grid_area, na.rm = T)
tot_mpa = sum(grid_mpa$protected_area_m2, na.rm = T)
prop = tot_mpa/tot_area


grid_use <- left_join(grid2, grid_surround %>% st_drop_geometry(), by = "Seq")

grid_sc1 <- grid_use %>% 
  mutate(prop = if_else(status %in% "protected", 1-prop, prop)) #these should all be 0

#grid cells surrounding mpas
n_surround <- grid_sc1 %>% 
  st_drop_geometry() %>% 
  filter(surrounding == "surrounding") %>% 
  tally()

#protected proportion to reallocate (calculated as area of each mpa/area of grid cells containing mpa)
prop_allocate = tot_mpa/tot_area

#allocate surrounding cells
grid_sc1 <- grid_sc1 %>%  
  mutate(FE_prop = if_else(surrounding %in% "surrounding",(prop_allocate/n_surround$n) +1 , prop),
         status = ifelse(surrounding %in% "surrounding","surrounding",status),
         status = ifelse(is.na(status),"unprotected",status)
  )

ggplot() +
  geom_sf(data = subset(grid_sc1, grid_sc1$FE_prop != 1),
          aes(fill = FE_prop)) +
  geom_sf(data = mpa_sf, aes(), fill = NA, color = "white") +
  scale_fill_viridis_b()

# Save data
ggsave(
  paste0(data_path,"spatial/gridded/",mpa_name,"_fe.png"),
  plot = last_plot()
)

```

## Save grided mpa FE

```{r eval = T, echo = F}

# Go back to df
grid_df <- as.data.frame(grid_sc1) %>% 
  select(index = Seq,FE_prop,status) %>%  
  mutate(mpa = mpa_name) %>% 
  filter(!is.na(FE_prop))

# Save data
write_csv(
  grid_df,
  paste0(data_path,"spatial/gridded/",mpa_name,"_fe.csv"),
)


```

## Create MPA layer

```{r save_layers, eval = F}

# Load all grid cells
list_mpas <- list.files(paste0(data_path,"spatial/gridded/"),pattern = ".csv",full.names = T)[-1]

dbem_grid <- my_data("dbem_coords")

mpas_grid <- bind_rows(
  lapply(list_mpas, read_csv 
         # col_types = col_types
         )
  ) %>% 
  # Fix minimal negative values when full protection
  mutate(
    fe_prop = ifelse(FE_prop < 0,0,FE_prop)
  ) %>% 
  select(-FE_prop)

mpas_grid %>% 
  left_join(dbem_grid) %>% 
  ggplot() +
  geom_tile(
    aes(
      x = lon,
      y = lat,
      fill = mpa
    ),
    # alpha = 0.8
  ) +
  scale_fill_viridis_d() +
  my_land_map() +
  coord_sf(
    xlim = c(-95,-77),
    ylim = c(-4,9)
  ) 
  # facet_wrap(~mpa)

# Save grid with all mpas
write_csv(
  mpas_grid,
  paste0(data_path,"spatial/gridded/all_mpa_grid_fe.csv"),
)



# Load DBEM grid
my_data("dbem_coords") %>% 
  left_join(mpas_grid,
            by = "index") %>% 
  mutate(FE_prop = ifelse(is.na(fe_prop),1,
                          ifelse(fe_prop < 0,0,
                                 fe_prop)
  )
  ) %>% 
  # ggplot() +
  # geom_tile(
  #   aes(
  #     x = lon,
  #     y = lat,
  #     fill = FE_prop
  #   )
  # )
  select(FE_prop) %>% 
  write.table(file = paste0(data_path,"spatial/compute_canada/etp_m_reserve.txt"),
              sep="\t", col.names = F, row.names = F)


```

# Create SF will all MPAs

```{r, eval = F}
mpa_name <- c(
  "Galapagos_Ecuador",
  "Hermandad_Ecuador",
  "Yurupari _Malpelo_Colombia",
  "PN_IslaCoco_CostaRica",
  "Malpelo_Colombia",
  "CoibaCoord_Panama",
  "Coiba_Panama",
  "PN_IslaCoco_CostaRica",
  "AMM_Bicentenario_CostaRica",
  "CLomas Sub  Cuenca PacNor",
  "Gorgona"
)

path_mpa <- paste0(data_path,"spatial/cmar_capas/",mpa_name,".shp")


sf_list <- lapply(path_mpa, st_read)

# Check the CRS of each sf object and determine a common CRS
common_crs <- st_crs(sf_list[[1]])  # You can choose any sf object or a standard CRS

# Transform all sf objects to the common CRS
sf_list_transformed <- lapply(sf_list, function(x) st_transform(x, crs = common_crs))

# Identify the common columns
common_cols <- Reduce(intersect, lapply(sf_list_transformed, names))

# Standardize each sf object to have the same columns
sf_list_standardized <- lapply(sf_list_transformed, function(x) {
  x[common_cols]
})

# Combine the standardized sf objects
combined_sf <- do.call(rbind, sf_list_standardized)



ggplot(data = combined_sf) +
  geom_sf() +
  theme_minimal()


write_sf(combined_sf,
         paste0(data_path,"spatial/cmar_capas/all_cmar_mpas.shp"))

```

# Extract ICCAT grid

```{r, eval = F}

dbem_sf <-st_as_sf(dbem_grid,
                   coords = c("lon", "lat")
) %>% 
  st_set_crs(4326) #%>%
# st_transform(crs = "+proj=eck4")

st_crs(dbem_sf) = 4326


# RFMO regions
# RFMO data
sf_rfmo <- my_sf("RFMO") %>% 
  filter(rfmo_nm_s %in% c("IATTC")) %>% 
  group_by(rfmo_nm_s) %>% 
  summarise(geometry = st_union(geometry))

st_crs(sf_rfmo) = 4326

rfmo_dbem <- st_join(dbem_sf,
                     sf_rfmo,
                     join = st_intersects)

# Select only high seas (i.e., remove waters within EEZs)
rfmo_dbem_hs <- rfmo_dbem %>% 
  as.data.frame()%>% 
  select(-geometry) %>% 
  clean_names() %>% 
  filter(!is.na(rfmo_nm_s)) # remove areas where no tuna RFMO exists (some high seas pockets)


write_csv(rfmo_dbem_hs,
          paste0(data_path,"spatial/iattc_gridded.csv"))


```

