---
title: "Spatial analysis and species selection"
author: "Juliano Palacios Abrantes et al"
date: "2023-10-02"
output: html_document
---

```{r setup, include=FALSE}

library(MyFunctions)

my_lib(
  c(
    "readxl",
    "tidyverse",
    "sf",
    "st",
    "janitor",
    # For grid estimation 
    "spatialEco", "geosphere","raster","units","matrixStats","rmapshaper", "igraph"
  )
)

# Fix new updates of sf package
sf::sf_use_s2(use_s2 = FALSE)

select <- dplyr::select

knitr::opts_chunk$set(echo = TRUE)


# Change paths to your computer

data_path <- "~/Library/CloudStorage/GoogleDrive-jepa88@gmail.com/My Drive/lenfest_mpa_project/data/"

```

# Pre-Analysis

This script's objective is prepare the spatial and species data for the project. For the species, we want to kow what information we already have for modelling. For the spatial component we want to re-grid all shapefiles used in the project to match the DBEM while identifying which gird cells are Protected by an MPA, which are surrounding an MPA, and which are absent. 

# Species explortion

## Load Species data

```{r species_list, eval = F, echo = F}

# ETP species list provided by MarViva
etp_species_metadata <- read_excel(paste0(data_path,"species/lenfest_species_metadata.xlsx"))

# Species
etp_species <- etp_species_metadata %>% 
  select(species)

# DBEM species
dbem_species <- my_path("Spp",name ="dbem_spp_list.csv", read = T)

# Exploited species
exploited_species <- my_data("sau_species") %>% 
  filter(taxon_key %in% dbem_species$taxon_key)

# Find matching species
etp_matching_species <- etp_species %>% 
  filter(species %in% exploited_species$taxon_name) %>% 
  group_by(species) %>% 
  tally() %>% 
  mutate(dbem = "yes") %>% 
  select(-n)
  
# Incorporate data into metadata
etp_species_metadata_update <- etp_species_metadata %>% 
  left_join(etp_matching_species,
            by = "species") %>% 
  mutate(dbem = ifelse(is.na(dbem),"no",dbem))

# write_csv(etp_species_metadata_update,
#           paste0(data_path,"species/etp_species_metadata.csv"),
#           )

```

# Spatial analysis

## Load in grid data

```{r grid, eval = T, echo = F}

grid <- read_sf(paste0(data_path,"spatial/worldsq_ea/", name ="worldsq_EA.shp"))

grid <- grid %>% filter(Lat > -4 & Lat < 9 & Lon > -95 & Lon < -77)

ggplot(grid) +
  geom_sf()
```

## Shapefile Data

```{r mpa_shape, eval = T, echo = F, message = F,warning = FALSE, cache = FALSE}


mpa_name <- 
  # "Galapagos_Ecuador"
  "Hermandad_Ecuador"
  # "Yurupari _Malpelo_Colombia"
  #"PN_IslaCoco_CostaRica"
  #"Malpelo_Colombia"
  #"CoibaCoord_Panama"
  #"Coiba_Panama" 
  #"PN_IslaCoco_CostaRica"

path_mpa <- paste0(data_path,"spatial/cmar_capas/",mpa_name,".shp")


suppressMessages(
mpa_sf <- st_read(path_mpa) %>% 
  # Remove the Z component for ease computation
  st_zm(drop = TRUE)
)
#get out coordinate reference system information 
# st_crs(mpa_sf)
st_crs(mpa_sf)$epsg
crs <- st_crs(mpa_sf)


ggplot(mpa_sf) +
  geom_sf(aes(), fill = "salmon")

ggsave(
  paste0(data_path,"spatial/gridded/",mpa_name,".png"),
  plot = last_plot()
)


```


### Identify grids that are MPAs, surrounding an MPA and no-protected

#### 1.1 Identify grids that are MPAs

In this step we identify which grid cells have an MPA completely or partially covering it. 

```{r mpa_overla, eval = T, echo = F, message = F}

# transform grid to shapefile crs
grid <- st_transform(grid, crs = st_crs(crs)) %>% 
  filter(PWater > 0)

# Intersect the grid and the MPA shapefile
grid_intersection <- st_intersection(grid, mpa_sf) %>%
  group_by(Seq) %>%
  summarise(geom = st_union(geometry)) %>%
  mutate(geom = st_sfc(geom),
         area = st_area(geom)) %>% 
  mutate(status = "protected") %>% 
  as.data.frame()

# Identify grid cells that have some level of MPA within them 
grid2 <- as.data.frame(grid) %>% 
  left_join(grid_intersection, by = "Seq") %>% 
  mutate(protected_area_m2 = as.numeric(area)) %>% 
  select(-geom) %>% 
  st_as_sf()

# Plot it
ggplot() + 
  geom_sf(data = grid2, 
          aes(fill = protected_area_m2)) +
  geom_sf(data = mpa_sf, 
          aes(), fill = NA, color = "white") +
  scale_fill_viridis_b()


```

#### 1.2 Estimate area

Here we estimate the proportion of the grid cell that is protected using the area protected ($area_p$) relative to the area of the grid cell ($area_g$) in order to reduce fishing effort in grid celss that contain an MPA ($FE_{mpa}$):

$FE_{mpa} = \frac{area_p}{area_g}$

```{r area_est, eval = T, echo = F}

grid2 <- grid2 %>% 
  mutate(grid_area = st_area(.)) %>%
  drop_units() %>% 
  mutate(
    prop = ifelse(status == "protected", (protected_area_m2/grid_area), 1)
  ) 


  ggplot() +
    geom_sf(data = grid2, aes(fill = prop)) +
    scale_fill_viridis_b("Proportion of grid\nprotected")
```

#### 1.4 Find surrounding grid cells 

Surrounding grid cells are limited to the grid cells immediately adjacent to a grid cell that is cover (complete or partially) by an MPA. The identification of surrounding grid cells is necessary to further re-allocate fishing effort to these cells as they benefit from the biomass spillover.


```{r surroundig, eval = T, echo = F, message = F}

grid_mpa <- grid2 %>% 
  select(OBJECTID, Seq, Lat, Lon, geometry, status, protected_area_m2, grid_area)

# Identify non-protected
grid_mpa_no <- grid_mpa %>% filter(is.na(status))

#create buffer
buffer <- st_buffer(grid_mpa %>% filter(status == "protected"),0.1)

intr <- st_intersection(grid_mpa_no, buffer)
intr_seqs <- c(intr$Seq)

grid_surround <- grid_mpa_no %>% 
  filter(Seq %in% intr_seqs) %>% 
  mutate(surrounding ="surrounding") %>% 
  select(Seq, surrounding)


ggplot() +
  geom_sf(data = grid_surround , aes(), fill = "darkblue") +
  geom_sf(data = grid_mpa %>% filter(status == "protected"), aes(), fill = "pink") +
  geom_sf(data = mpa_sf, aes(), fill = NA, color = "black") +
  ggtitle("Showing protected grid cells in pink and surrounding in blue")


ggsave(
  paste0(data_path,"spatial/gridded/",mpa_name,"_protected.png"),
  plot = last_plot()
)

rm(buffer)

```


### Reallocate fishing effort

Here we re-allocate fishing effort from the protected grid cells to those surrounding. We do this proportionally to the protected area and the number of surrounding grid cells. Right now, the proportion is accounted from all MPAs and re-distributed to all grid cells, but this can change. For this we first estimate the proportion to be allocated (*PropAllocate*):


$$PropAllocate = \frac{tot_{mpa}}{tot_{area}}$$

where $tot_{mpa}$ is the sum of the protected area ($m^2$) of all protected grid cells and $tot_{area}$ is the sum of the whole grided area (protected and surrounding). Then, we estimate the allocation of effort by first counting the number of surrounding grid cells and then allocating the proportion to the fishing effort of surrounding cells ($FE_{sur}$):

$$FE_{sur} = 1+\frac{PropAllocate}{n_{surround}}$$
This way, fishing effort in an MPA grid will be reduced by the proportion of the MPA in the grid ($FE_{mpa}$), in surroundings cells will be increased with the proportion allocated ($FE_{sur}$) while all other grid cells (no-protected) will have an DF at MSY.

```{r fiseffort, eval = T, echo = F}

#total proportion 
#this will help allocate fishing effort to the surrounding areas. 
tot_area = sum(grid_mpa$grid_area, na.rm = T)
tot_mpa = sum(grid_mpa$protected_area_m2, na.rm = T)
prop = tot_mpa/tot_area


grid_use <- left_join(grid2, grid_surround %>% st_drop_geometry(), by = "Seq")

grid_sc1 <- grid_use %>% 
  mutate(prop = if_else(status %in% "protected", 1-prop, prop)) #these should all be 0

#grid cells surrounding mpas
n_surround <- grid_sc1 %>% 
  st_drop_geometry() %>% 
  filter(surrounding == "surrounding") %>% 
  tally()

#protected proportion to reallocate (calculated as area of each mpa/area of grid cells containing mpa)
prop_allocate = tot_mpa/tot_area

#allocate surrounding cells
grid_sc1 <- grid_sc1 %>%  
  mutate(FE_prop = if_else(surrounding %in% "surrounding",(prop_allocate/n_surround$n) +1 , prop),
         status = ifelse(surrounding %in% "surrounding","surrounding",status),
         status = ifelse(is.na(status),"unprotected",status)
         )

ggplot() +
  geom_sf(data = subset(grid_sc1, grid_sc1$FE_prop != 1),
          aes(fill = FE_prop)) +
  geom_sf(data = mpa_sf, aes(), fill = NA, color = "white") +
  scale_fill_viridis_b()
  
# Save data
ggsave(
  paste0(data_path,"spatial/gridded/",mpa_name,"_fe.png"),
  plot = last_plot()
)

```